# DB Migration Plan: SQLite -> PostgreSQL

## Goal
- Keep current interview service behavior while moving persistence from SQLite to PostgreSQL.
- Minimize downtime and provide a rollback path.

## Current SQLite Schema

### `sessions`
| column | type | note |
| --- | --- | --- |
| `id` | `TEXT` | PK (UUID string) |
| `created_at` | `TEXT` | ISO-8601 |
| `updated_at` | `TEXT` | ISO-8601 |
| `summary` | `TEXT` | default empty string |

### `messages`
| column | type | note |
| --- | --- | --- |
| `id` | `INTEGER` | PK autoincrement |
| `session_id` | `TEXT` | FK -> `sessions.id` |
| `role` | `TEXT` | `user` or `assistant` |
| `text` | `TEXT` | message content |
| `created_at` | `TEXT` | ISO-8601 |

### `drafts`
| column | type | note |
| --- | --- | --- |
| `id` | `INTEGER` | PK autoincrement |
| `session_id` | `TEXT` | FK -> `sessions.id` |
| `content` | `TEXT` | draft content |
| `created_at` | `TEXT` | ISO-8601 |

## Target PostgreSQL Schema Mapping

### `sessions`
| SQLite | PostgreSQL | note |
| --- | --- | --- |
| `id TEXT` | `id UUID` | generated by app |
| `created_at TEXT` | `created_at TIMESTAMPTZ` | UTC |
| `updated_at TEXT` | `updated_at TIMESTAMPTZ` | UTC |
| `summary TEXT` | `summary TEXT` | default `''` |

### `messages`
| SQLite | PostgreSQL | note |
| --- | --- | --- |
| `id INTEGER` | `id BIGSERIAL` | PK |
| `session_id TEXT` | `session_id UUID` | FK |
| `role TEXT` | `role TEXT` | consider `CHECK` constraint |
| `text TEXT` | `text TEXT` | required |
| `created_at TEXT` | `created_at TIMESTAMPTZ` | UTC |

### `drafts`
| SQLite | PostgreSQL | note |
| --- | --- | --- |
| `id INTEGER` | `id BIGSERIAL` | PK |
| `session_id TEXT` | `session_id UUID` | FK |
| `content TEXT` | `content TEXT` | required |
| `created_at TEXT` | `created_at TIMESTAMPTZ` | UTC |

## Recommended Environment Strategy
- Development/Staging: Docker Compose PostgreSQL.
- Production: managed PostgreSQL service (RDS, Cloud SQL, Supabase, Neon, etc.).

## Migration Steps
1. Introduce DB abstraction in backend storage layer (SQLite and PostgreSQL adapters).
2. Add PostgreSQL schema migration scripts (recommended: Alembic).
3. Prepare one-time migration script:
- read SQLite rows in order
- transform timestamps to UTC `TIMESTAMPTZ`
- load into PostgreSQL within transaction batches
4. Run dry-run migration in staging and validate:
- session count
- message count
- draft count
- sample session integrity (messages order)
5. Dual-read validation window (optional):
- write remains SQLite
- read compare SQLite vs PostgreSQL for selected sessions
6. Cutover:
- enable maintenance mode (read-only or short write pause)
- run final incremental sync
- switch app DB connection to PostgreSQL
7. Post-cutover monitoring:
- API errors (`db` category)
- query latency
- connection pool saturation

## Downtime Plan
- Preferred: short write pause (1-5 minutes) during final incremental sync and connection switch.
- If strict no-downtime required: dual-write period, then phased read switch. Complexity increases.

## Rollback Plan
1. Keep latest SQLite backup before cutover.
2. Keep application feature flag for DB backend selection.
3. On critical issue:
- switch backend flag from PostgreSQL back to SQLite
- restart backend
- verify `/health` and key interview APIs
4. Investigate PostgreSQL issue and rerun migration in staging before second cutover.

## Validation Checklist
- `/health` returns `db=up`
- `POST /interview/start`, `POST /interview/chat`, `GET /interview/session/{id}` pass
- `POST /interview/draft`, `GET /interview/draft/latest/{id}` pass
- Data row counts match expected values
